#!/usr/bin/python
# -*- coding: utf-8 -*-
import sys,re,os,argparse,datetime
parser = argparse.ArgumentParser(description='Match the coordinates of a request (GFF-like) file on a reference (GFF-like) file.',epilog='Author: Gildas Lepennetier: gildas.lepennetier@hotmail.f')
parser.add_argument('-req', required=True, type=argparse.FileType('r'),help='request file (list of elements to match)')
parser.add_argument('-ref', required=True, type=argparse.FileType('r'),help='reference file (where to search for)')
parser.add_argument('-out', required=False, type=argparse.FileType('w'),default=sys.stdout, help='output file')
parser.add_argument('-sep',type=str,default='\t',required=False,help='separator (default: \\t)')
parser.add_argument('-endline',type=str,default='\n',required=False,help='separator (default: unix \\n)')
parser.add_argument('--version', action='version', version='%(prog)s 07-08-2014')#version display
parser.add_argument('--verbose', '-v', action='count',default=0,help='add flag(s) to increase verbosity')# count the level of verbosity, +1 for each -v flag
parser.add_argument('-option',type=str,default='in',required=False,help='more option where to search. Default is "in" meaning: "Req_start > Ref_start" and "Req_end < Ref_end"')
parser.add_argument('-ref_chr',default=1,type=int,required=False,help='column number for starts (default=3)')
parser.add_argument('-req_chr',default=1,type=int,required=False,help='column number for starts (default=3)')
parser.add_argument('-ref_start',default=4,type=int,required=False,help='column number for starts (default=4)')
parser.add_argument('-ref_end',default=3,type=int,required=False,help='column number for starts (default=3)')
parser.add_argument('-req_start',default=4,type=int,required=False,help='column number for starts (default=4)')
parser.add_argument('-req_end',default=3,type=int,required=False,help='column number for starts (default=3)')
parser.add_argument('-progress',default=False,action='store_true',help='add this flag if you want to have a progress estimate. this put also one flag --verbose')
parser.add_argument('-onlymatch',default=False,action='store_true',help='add this flag if you want ONLY the match')
parser.add_argument('-ref_header',action='store_true',default=False,help='add this flag if reference file have a header (first line with names). If no header in input, no header in output')
parser.add_argument('-req_header',action='store_true',default=False,help='add this flag if request file have a header (first line with names)')
parser.add_argument('--copy',action='store_true',help='Display Copyright informations')
parser.add_argument('--author',action='store_true',help='Display author informations')
args=vars(parser.parse_args())
if args['author']:
	print ("LEPENNETIER Gildas - gildas.lepennetier@hotmail.fr")
	exit()
if args['copy']:
	print ("Copyright 2014 LEPENNETIER Gildas")
	exit()
Ref_chr_index   = int(args['ref_chr']) -1
Req_chr_index   = int(args['req_chr']) -1
Ref_start_index = int(args['ref_start']) -1
Ref_end_index   = int(args['ref_end']) -1
Req_start_index = int(args['req_start']) -1
Req_end_index   = int(args['req_end']) -1
OUT=args['out']
LINES_REF=args['ref'].readlines()
LINES_REQ=args['req'].readlines()
firstline1=""
firstline2=""
if args['req_header']:
	firstline2=LINES_REQ[0].split(args['endline'])[0]
	lines_file2=LINES_REQ[1:]
else:
	firstline2=args['sep'].join([ "." for el in LINES_REQ[0].split(args['endline'])[0].split(args['sep']) ])
if args['ref_header']:
	firstline1=LINES_REF[0].split(args['endline'])[0]
	lines_file1=LINES_REF[1:]
else:
	firstline1=args['sep'].join([ "." for el in LINES_REF[0].split(args['endline'])[0].split(args['sep']) ])
if args['ref_header'] or args['req_header']:
	OUT.write(args['sep'].join([firstline2,"matching_statut",firstline1]) + args['endline'])
#Feed the dictionnary with lines of the GFF = ref | splice everything only once
GFF_dico={}
for rline in LINES_REF: #open GFF lines
    line=rline.split(args['endline'])[0].split(args['sep'])
    ID=line[Ref_chr_index]
    if ID in GFF_dico:
        GFF_dico[line[Ref_chr_index]].append(line)
    else:
        GFF_dico[line[Ref_chr_index]]=[line]
# load request file - the csv
requestLines=args['req'].readlines() #request line
######################
kk=0
nbTot=len(LINES_REQ)
if args['progress'] or args['verbose']>0:
    sys.stderr.write("Loading data...%s"%args['endline'])
for rawReqLine in LINES_REQ:
    kk+=1
    if kk % 100 == 0 and args['progress']:
        sys.stderr.write("\r%s %% - (%s / %s) - %s"%( round(float(kk)/nbTot*100,1),kk,nbTot,datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")))
    if kk == nbTot and args['progress']:
        sys.stderr.write("\r%s %% - (%s / %s) - %s%s"%( round(float(kk)/nbTot*100,1),kk,nbTot,datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S"),args['endline']))

    ReqLine  =rawReqLine.split(args['endline'])[0].split(args['sep'])
    ### here
    ReqScaff =ReqLine[Ref_chr_index].split(" ")[0]#extract request
	MATCHED=False
    try:
        for RefLine in GFF_dico[ReqScaff]:#extract only the interesting scaffold
            Ref_start=int(RefLine[Ref_start_index])
            Ref_end  =int(RefLine[Ref_end_index])
            Req_start=int(ReqLine[Req_start_index])
            Req_end  =int(ReqLine[Req_end_index])
            if args['option'] == 'in':
                if Req_start > Ref_start and Req_end < Ref_end:
                    MATCHED=True
                    OUT.write ( args['sep'].join( [ str(el) for el in ReqLine+['match']+RefLine ])+args['endline'] )
            else:
                pass                
        if not MATCHED:
            if not args['onlymatch']:
                OUT.write ( args['sep'].join( [ str(el) for el in ReqLine+["nomatch_inElement"]  ])  +args['endline'] )
    except KeyError:
        if args['verbose'] > 0:
            if args['progress']:
                sys.stderr.write("\tKeyError line %s\n"%(kk))
            else:
                sys.stderr.write("\tKeyError line %s"%(kk))
        if not args['onlymatch']:
            OUT.write ( args['sep'].join( [ str(el) for el in ReqLine+["nomatch_keysError"]  ])  +args['endline'] )
    except ValueError:
        if args['verbose'] > 0:
                if args['progress']:
                        sys.stderr.write("\tValueError line %s\n"%(kk))
                else:
                        sys.stderr.write("\tValueError line %s"%(kk))
        if not args['onlymatch']:
            OUT.write ( args['sep'].join( [ str(el) for el in ReqLine+["nomatch_ValueError"]  ])  +args['endline'] )
    except IndexError:
        sys.stderr.write("\tIndexError line %s - check your column numbers\n"%(kk, ))
        exit()