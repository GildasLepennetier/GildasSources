#!/usr/bin/python3
import sys,argparse
##########################################
#### some function for one day
# Load a fasta file
#### manual FASTA ####
# Load a fasta file - rough
def Fasta_To_Dico_path(path,idtag='>',endline="\n"):
    with open(path,'r') as file:
        dico={}
        for line in file:
            line=line.split(endline)[0]
            if line[0]==idtag:
                ID=line[1:] #avoid '>' in IDs
                dico[ID]='' 
            else:
                dico[ID]+=line
    return dico
# Load a fasta file - rough
def Fasta_To_Dico_file(file,idtag='>',endline="\n"):
    dico={}
    for line in file:
        line=line.split(endline)[0]
        if line[0]==idtag:
            ID=line[1:] #avoid '>' in IDs
            dico[ID]=''
        else:
            dico[ID]+=line
    return dico
#### LOAD FASTA BIOPYTHON ####
def loadFasta(adresse,endline="\n"):
    from Bio import SeqIO
    dico={}
    for seq_record in SeqIO.parse(adresse, 'fasta'):
        ID=str(seq_record.description)
        SEQ=str( seq_record.seq.split(endline)[0] )
        if ID not in dico.keys():
            dico[ID]=SEQ
        else:
            print("ERROR: %s already exist as key!"%ID)
    return dico
#### Give the reverse complement of a DNA sequence, change also if iupac nucleotide ####
def revCompl_DNA(seq):
    #Return reverse complement of dna, but does not change in case of N, Y, ...
    reverse = []
    if seq:
        for letter in seq: #remplir avec le complementaire
            CORRESPONDANCE={"A":"T","a":"t","C":"G","c":"g","G":"C","g":"c","T":"A","t":"a",#usual ACGT, case conserve
                            "R":"Y","r":"y","Y":"R","y":"r",#iupac R=A/G, Y=C/T
                            "S":"W","s":"w","W":"S","w":"s",#S=G/C, W=A/T
                            "K":"M","k":"m","M":"K","m":"k",#K=G/T, M=A/C
                            "B":"V","b":"v","V":"B","v":"b",# B=C/G/T, V=A/C/G
                            "D":"H","d":"h","H":"D","h":"d"}# D=A/G/T, H=A/C/T
            if letter in CORRESPONDANCE.keys():
                reverse.append(CORRESPONDANCE[letter])
            elif letter in ['u','U']:
                print ('error, must work on DNA, and I found nome U or u')
            else:
                reverse.append(letter)
        return ''.join(reverse[::-1]) #inverser
    else:
        return ""
#usefull
# insert in string, each X letter () perfect to format a fasta file with 80 nt per line
def insert_in_string(string,insert="\n",each=80):
    string2=""
    ii=0
    for letter in string:
        ii+=1
        if ii % each == 0 :
            string2=string2+letter
            string2=string2+insert
        else:
            string2=string2+letter
    return string2
##########################################
parser = argparse.ArgumentParser(description='Make the reverse complement of a sequence in columns of a csv file',epilog='Author: Gildas Lepennetier: gildas.lepennetier@hotmail.fr')
parser.add_argument('-in',required=False,type=argparse.FileType('r'),default=sys.stdin, help='input file')
parser.add_argument('-out',required=False,type=argparse.FileType('w'),default=sys.stdout, help='output file')
parser.add_argument('-cmd',type=str,required=True,help='commande for the tool: [csv_to_fasta | fasta_to_csv | fasta_freq ]')

parser.add_argument('-header',action='store_true',default=False,help='add this flag if you have / want an header (fist line with names of columns)')
parser.add_argument('-seqCol',type=int,required=False,help='[csv_to_fasta] : where to find the sequence')
parser.add_argument('-id',type=str,required=False,help='[csv_to_fasta] : where to find the id. Can be a coma-separated list of column, will be join by _')
parser.add_argument('-idJoin',type=str,default="_",required=False,help='[csv_to_fasta] : If several columns for id, this will be the spacer. default: "_" ')
parser.add_argument('-ntPerLine',type=int,default=80,required=False,help='[csv_to_fasta] : How many nucleotides per line for the fasta? default=80')
parser.add_argument('-rmId',action='store_true',default=False,help='[fasta_to_csv] add this flag if you want to remove the id of the fasta, will be in first column')
parser.add_argument('-keepIds',type=str,help='[extract] extract only those ids in a fasta format. coma-separated')
parser.add_argument('-Marker',type=str,default='>',required=False,help='mark for the name of a record (default: >)')

parser.add_argument('-endline',type=str,default='\n',required=False,help='separator (default: unix \\n)')
parser.add_argument('-sep',type=str,default='\t',required=False,help='separator (default: \\t)')
parser.add_argument('--version', action='version', version='%(prog)s v1.0')#version display
parser.add_argument('--verbose', '-v', action='count',default=0,help='add flag(s) to increase verbosity')# count the level of verbosity, +1 for each -v flag

parser.add_argument('--copy',action='store_true',help='Display Copyright informations')
parser.add_argument('--author',action='store_true',help='Display author informations')
args=vars(parser.parse_args())
if args['author']:
    print ("LEPENNETIER Gildas - gildas.lepennetier@hotmail.fr")
    exit()
if args['copy']:
    print ("Copyright 2014 LEPENNETIER Gildas")
    exit()
##########################################
"""
    [csv_to_fasta]
Transfrome a csv file in a fasta file, using the column specified for the sequence and the id (the id can be the concatenation of several columns)

    [fasta_to_csv]
Transform a fasta file to a csv file, with the id on the first column and the sequence on a second column

	[fasta_freq]
Make the nucleotide frequency from a fasta file
"""
##########################################
if args['cmd'] == 'csv_to_fasta':
    if args['verbose'] > 0:
        sys.stderr.write("Info: starting csv_to_fasta"+args['endline'])
    if not args['seqCol']:
        print ("Error: you should give a column number where the sequence is located")
    if not args['id']:
        print ("Error: you should give a column number where the id is located. Advice: check the each id is uniq, or give a coma sep list of clumn for the id")
    
    seqCol_index=args['seqCol'] -1 #python index starts at 0
    id_index=[ int(el)-1 for el in args['id'].split(',') ] #python index starts at 0
    k=0
    for rline in  args['in']:
        k+=1
        if args['header'] and k==1:
            pass
        else:
            line=rline.split(args['endline'])[0].split(args['sep'])
            
            ID= args['Marker'] + args['idJoin'].join([el for el in [ line[i] for i in id_index ] ]) + args['endline'] #Marker > + id_and_other + \n
            SEQ=insert_in_string(string=line[seqCol_index],insert=args['endline'],each=args['ntPerLine']) # seq
            
            args['out'].write( ID + SEQ + args['endline'])
##########################################
if args['cmd'] == 'fasta_to_csv':
    if args['header']:
        if not args['rmId']:
            args['out'].write("fasta_id" + args['sep'] + "sequence" + args['endline'] )
        else:
            args['out'].write("sequence" + args['endline'] )
    k=0
    for rline in args['in']:
        k+=1
        line=rline.split(args['endline'])[0]
        if line:
            if not args['rmId']:
                if line[0] == args['Marker']:
                    if k > 1:
                        args['out'].write(args['endline'])#need to go back to line, but not for first line
                    ID=line.split(args['Marker'])[1] # extract id
                    args['out'].write(ID + args['sep'])
                else:
                    args['out'].write(line) # print sequence
                
            else: #do not keep id
                if line[0] == args['Marker']:
                    if k > 1:
                        args['out'].write(args['endline'])#need to go back to line, but not for first line
                else:
                    args['out'].write(line) # print sequence
    args['out'].write(args['endline']) #last line: should have that
##########################################
if args['cmd'] == 'fasta_freq':
    COUNT={'A':0.0,'C':0.0,'G':0.0,'T':0.0,'N':0.0,'nb':0.0}
    for rline in args['in']:
        line=rline.split(args['endline'])[0]
        if line:
            if line[0] != args['Marker']:
                COUNT['A'] += line.count("A") + line.count("a")
                COUNT['C'] += line.count("C") + line.count("c")
                COUNT['G'] += line.count("G") + line.count("g")
                COUNT['T'] += line.count("T") + line.count("t")
                COUNT['N'] += line.count("N") + line.count("n")
                COUNT['nb'] += len(line)
    FREQ=dict()
    for key in COUNT.keys():
        if key not in ['nb']:
            if COUNT[key] != 0:
                FREQ[key] = COUNT[key]/COUNT['nb']
    
    if FREQ['A']+FREQ['C']+FREQ['G']+FREQ['T'] !=1:
        TOT=FREQ['A']+FREQ['C']+FREQ['G']+FREQ['T']
        sys.stderr.write("Warning: total ACGT = %s ; N=%s%s"%(TOT,int(COUNT['N']),args['endline']))
    #print (COUNT)
    args['out'].write( args['sep'].join ( [ str(el) for el in [ FREQ['A'],FREQ['C'],FREQ['G'],FREQ['T'] ] ] ) +args['endline'] )
##########################################
if args['cmd'] == 'extract':
    if not args['keepIds']:
        sys.stderr.write("Error: -keepIds missing, you need to specify ids to keep (coma-sep)%s"%(args['endline']))
        exit()
    IDS=args['keepIds'].split(",")
    p=False
    for line in args['in']:
        if line[0] == args['Marker']:
            #sys.stderr.write("%s\n"%(line.split(" ")[0]))
            if line.split(" ")[0].split(args['Marker'])[1] in IDS:
                p=True
            else:
                p=False
        if p:
            sys.stdout.write(line)
